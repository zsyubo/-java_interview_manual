# `Redis为什么是单线程但是性能这么高？`
nginx是单线程程序，底层采用多路复用(这样就不会在IO上浪费过多时间)，同时也是基于纯内存的，所以才能这么快。而且单线程避免了线程切换和静态产生的消耗。Redis各个数据结构也设计的比较好，所以不存在O(n)的情况。

当然单线程的缺陷还是有，对那些Redis指令为O(n)级别的指令要谨慎使用：比如keys命令。

**keys**    
keys是遍历算法，复杂度是O(n)，redis在2.8提供了替代的scan命令。虽然scan也是O(n)， 但是scan可以通过游标分布进行，不会阻塞线程，提供limit参数。

**scan遍历算法**

看不懂，以后再加。

# `Redis用过哪些数据数据，以及Redis底层怎么实现 `
- string：定义了SDS数据结构用于实现字符串，重写了大量字符串处理的模板方法
- list：结合了双向链表和ziplist压缩列表，在查询和修改的效率上达到了平衡
- hash：有zipmap和dict两种实现方式，zipmap基于列表，dict基于链表
- set：基于柔性数组[1]实现，如果集合过大，会使用dict进行存储
- zset：有两种实现方式，一种是使用zipmap将数据按照值顺序存储，一种是基于跳跃表存储

# `知道动态字符串sds的优缺点么(redis底层数据结构之一)？`
高端题，以后再搞。

# `Redis缓存穿透，缓存雪崩 `
缓存穿透：一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

解决方法：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。或者布隆表达式

缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。

解决方案方案：是缓存缓存不要在同一时间失效，尽量是失效时间更均匀。

缓存击穿：对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。

解决方案：使用redis的setnx互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。

或者使用分布式锁。

# `如何使用Redis来实现分布式锁` 
jedis.set(key, value, nxxx, expx, time)，这里最后一个time是防止超时。

当然没那么简单，因为可能其他原因造成获取锁的时间笔记setnx的时间更长，这时候可以后台跑一个线程，专门去延长超时时间， 不过性能就不行了。

在解说时使用lua脚本，因为解锁前要先判断是不是自己加的锁，是的话采取del操作，因为不是原子性，所以使用lua。

# `Redis的并发竞争问题如何解决` 
redis是单线程，所以不会出现。

# `Redis持久化的几种方式，优缺点是什么，怎么实现的` 
RDB、AOF、4.0的回合持久化。     
RBD底层采用COW实现，也就是fork一个子进程。

# `Redis的缓存失效策略` 
redis可以设置内存大小，默认是没有限制的。     
- noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。
- allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
- volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
- allkeys-random: 所有key通用; 随机删除一部分 key。
- volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
- volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。

# `Redis集群，高可用，原理`
redis集群方案有 主从、哨兵和cluster。如果数据量少、节点少可以直接使用哨兵。

**哨兵**
哨兵是特殊的模式，他会检测master和slave的状态，如果master挂了，那么他会手动吧slave切换成master，当有多个哨兵时，会进行投票，切换成功后(客观下线)，就会通过发布订阅模式让各个哨兵吧自己监控的从服务器切换成master，对客户端而已，一切都是透明的。当然缺点也是有的：在主从切换的时候是不可用的。

**哨兵主从切换流程**
1. 将slave1脱离原从节点，升级为主节点(通过命令)
2. 将从节点slave-2执向新的主节点
3. 通知各客户端主节点以更换。

# `Redis缓存分片 `
分片策略为一致性Hash算法

# `Redis的数据淘汰策略`

# `一致性Hash算法`

# `项目使用缓存需要注意些什么`

# `Redis 主从同步？`
主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。



# `redis和MQ如何平滑的扩容与缩容？ `

## ## redis
redis cluster的扩容比较简单

**扩容**
先加入集群，在迁移槽位。

扩容顺序是先增加Master节点在增加Slave从节点。使用redis提供的ruby脚本。

**缩容**

先删除slave节点，在移除槽位到其他节点，再删除Master节点。

# `Redis既然是单线程，但是他惰性删除时如何确定时间的(定时任务)？ `
todo

# `Redis通信协议 `
Reids使用的通信协议为RESP，是一个直观的文本协议。

# `redis 的数据如何与数据库保持一致？`
如果不存在数据库主从的情况，可以先delete缓存，操作完数据库在set缓存，因为即使失败了，也只是损失一次Cache miss。

**有主从的情况**

这中就比较复杂了，因为我们一般查数据是查的从库，但是上面如果操作数据库成功，但是操作缓存时除了问题，造成了Cache miss，那么会从从库去查，如果这是数据还没同步到从库， 那么缓存的数据就是不正确的。
1. 一种解决办法是定义定心缓存数据
2. 或者从主从入手，订阅Binlog，当发现数据更改时主动去更新缓存(建议)
3. 第三种时产生数据写入动作一段时间后强制读主库来加载缓存。比如在redis中写入一条数据，dbname+tablename+id，value=“”，expire=3s，当应用能查询到有数据时就从主库中查询。

