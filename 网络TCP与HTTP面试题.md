# `http1.0 和 http1.1 有什么区别。`

#  `TCP 三次握手和四次挥手的流程，为什么断开连接要 4 次,如果握手只有两次，会出现什么。（这个问题很多变种：比如为什么需要3次，2次行不行。）`

# `TIME_WAIT 和 CLOSE_WAIT 的区别。`

# `说说你知道的几种 HTTP 响应码，比如 200, 302, 404。`

# `当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。`

# `TCP/IP 如何保证可靠性， 说说 TCP 头的结构。`

# `如何避免浏览器缓存。`

# `如何理解 HTTP 协议的无状态性。`

# `简述 Http 请求 get 和 post 的区别以及数据包格式。`

# `HTTP 有哪些 method `

# `简述 HTTP 请求的报文格式。`

# `HTTP 的长连接是什么意思。`

# `HTTPS 的加密方式是什么， 讲讲整个加密解密流程。`

# `Http 和 https 的三次握手有什么区别。`

# `什么是分块传送。`

# `Session 和 cookie 的区别`

# `tcp流量控制 和 拥塞控制`
# `tcp有keep-alive机制，为什么应用层还需要做心跳？`
`默认的tcp keep-alive超时时间太长，默认是7200秒，也就是2个小时。`
**socks proxy会让tcp keep-alive失效**
socks协议只管转发TCP层具体的数据包，而不会转发TCP协议内的实现细节的包（也做不到），参考socks_proxy。
所以，一个应用如果使用了socks代理，那么tcp keep-alive机制就失效了，所以应用要自己有心跳包。socks proxy只是一个例子，真实的网络很复杂，可能会有各种原因让tcp keep-alive失效。
**移动网络需要信令保活**
前两年，微信信令事件很火，搜索下“微信 信令”或者“移动网络 信令”可以查到很多相关文章。
> https://blog.csdn.net/znzxc/article/details/82054387
# `http的keep-alive和tcp的keepalive区别`
**tcp的keepalive**
链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。
TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。
**http的keep-alive**
主要是为了保持tcp连接的打开，因为默认http是发送一次数据就关闭的，但是在大量请求的情况下，频繁建立连接时不必要且浪费资源的。http的keep-alive就是通道的重复使用。
在HTTP 1.1版本后，默认都开启Keep-Alive模式，只有加入加入` Connection: close`才关闭连接，当然也可以设置Keep-Alive模式的属性，例如` Keep-Alive: timeout=5, max=100`，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。