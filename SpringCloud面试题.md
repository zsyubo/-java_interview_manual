# # `Eureka`
##  ## eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？
eureka是AP系统，同时是去中心化的，也就是所有节点都是对等的。
zookeeper是CP系统，中心化的，要进行选举，有learder、follower节点。    
**zookeeper不适合的原因**
zookeeper适合做分布式协服务(比如分布式锁等))，但是做服务发现不是很好，因为服务发现并不需要100%的一直性，很多时候更需要是100%的可用性。zookeeper正在选举时时不对外提供服务的，而且出现网络分区时，这个集群也无法对外提供服务(可读不可写)。

## ## `eureka原理`
蛋疼的开放性问答。。。说实话，这块建议自己看下源代码，这里面其实能深究的地方挺多的。low一点扯一下各个延迟时间。，高端一点可能就要扯下具体实现了。
eureka分为client和Server端。     
### ### `client`
主要用于服务注册和发现的java客户端。   
**`启动阶段：`**
1. 读取配置文件，封装服务注册信息为EurekaClientConfig。
2. 封装当前客户端信息为EurekaInstanceConfig
3. 拉取服务注册表信息并缓存到本地
4. 在Eureka中注册自己(待研究:com.netflix.discovery.DiscoveryClient#register)。
直接请求estApi。
5. 初始化定时任务：续约、心跳、缓存刷新等。

**`应用执行阶段`**
1. 定时发送心跳到EurekaServer注册中心维持注册表的续约。
2. 定时从注册中心拉取注册表信息更新本地注册表。
3. 监控当前应用信息，如果发生改变，则及时在注册中心更新(todo具体怎样需要在研究下)

**`销毁阶段`**
1. 通过rest Api在注册中心注销自己。

### ### `server`
server主要有以下功能：
1. 服务注册
2. 接受客户端的服务心跳
3. 服务剔除
4. 服务下线
5. 集群同步
6. 获取服务注册表中的信息。
#### ####  服务注册原理
直接使用石杉老师总结的图
![avatar](https://s2.ax1x.com/2019/10/13/uxpAHO.jpg)
1. 首先接受到客户端的注册请求，写入到服务注册表，期间会有定时任务来检查心跳。
2. 立即同步到ReadWrite缓存
3. 定时同步到ReadOnly缓存。当客户端拉取服务注册列表时就从此列表拉取。

这样读写分离的原因应该是为了支持高并发。

> https://www.jianshu.com/p/c18db3a2efc6

## ## `eureka集群原理`
Eureka所有节点都是对等，Server在启动过程中会先从其他peer节点拉取注册信息，类似客户端拉取，但是这里的拉取是遍历整个集群，力求最全数据。`在拉取的时候，此server是不可用的，客户端无法请求`。   
为了保证整个集群的一致性，每个Server对本地注册表进行管理时，都会讲对应的所有操作同步到所有peer节点。   
既然涉及到同步，那么就可能存在冲突的问题：eureka通过版本号机制解决(具体我也么没深究过，慢慢研究吧。。)。 

## ## `eureka保护模式`
在网络中可能存在这样一种情况，eureka server与client间形成了分区或者网络一段时间内发生了 异常，所有的服务都没能够进行续约，Eureka Server就把所有的服务都剔除了，这样显然不太合理。所以，就有了自我保护机制，当短时间内，统计续约失败的比例，如果达到一定阈值，则会触发自我保护的机制，在该机制下， Eureka Server不会剔除任何的微服务，等到正常后，再退出自我保护机制。自我保护开关(eureka.server.enable-self-preservation: false)。

## ## `eureka优化`
`关闭保护模式`：在一般的企业内网，网络其实还是比较稳定的，没有必要开启。不过也不是绝对，开启也没问题，毕竟万一出现极端问题了？
### ### 时间优化
1. 客户端拉取注册表信息的时间，默认是30s，但是比较久，个人建议可以改的短一些。
2. 客户端续约时间：默认30s，个人建议改短一些。
3. 服务端刷新ReadOnly缓存的时间，默认30s，个人建议可以改的短一些。
4. 修改服务端默认心跳超时时间：90s
5. 服务端剔除失效节点循环时间：默认60s，也就是一个及节点心跳超时最坏情况，要120秒才会剔除，太久了。60*2s > 90s。


# # `feign\Ribbon`
## ## `你们各个微服务之间的调用时怎么做的？`
feign+ribbon来做微服务之间的交互。feign是rest网络请求客户端，ribbon是负载均衡器组件。

## ## `feign原理`
底层通过动态代理来进行接口请求。

## ## `feign优化`
1. 请求响应压缩，http中的gzip。
2. feign默认采用httpClient，性能不是太好。可以替换Okhttp，性能好一点(网上大佬说的)。

## ## `Ribbon负载均衡`
1. RondomRule: 随机策略。
2. RoundRobinRule：轮询策略。`默认`
3. 响应时间加权策略。响应时间越长，权重越低。
4. RetRule：重试策略。

## ## 如何实现自定义的负载均衡算法？
实现AbstractLoadBalancerRule类

## ## `Ribbon重试策略`
在整合 Ribbon 的情况下，不使用 Feign 重试，而是使用 Ribbon 的重试。
先加入spring-retry依赖，在修改如下配置
```
  ribbon:
    ConnectTimeout: 250 # Ribbon的连接超时时间
    ReadTimeout: 1000 # Ribbon的数据读取超时时间
    OkToRetryOnAllOperations: true # 是否对所有操作都进行重试
    MaxAutoRetriesNextServer: 1 # 切换实例的重试次数
    MaxAutoRetries: 1 # 对当前实例的重试次数
```
https://blog.csdn.net/qq_37334135/article/details/89070588


# # `Hystrix`
## ## `什么是Hystrix?为什么要使用他？`
是一个针对分布式系统容错处理的开源组件，主要用于防止分布式系统的雪崩效应。
![avatar](https://s2.ax1x.com/2019/10/13/uxGuTO.jpg)   
如上图，开始只是库存服务不可用，最终一层层请求堆积，造成了全部服务不可用。而Hystrix就是用来防止此种情况的发生，具有如下功能：
1. 当依赖的服务出现高延迟或者失败时，为系统提供保护和控制。
2. 在复杂的系统中防止级联失败(雪崩效应)。
3. 快速失败的同时能够快速恢复。
4. 提供失败回滚和优雅的服务降级策略。
5. 提供近实时的监控、报警和运维手段。




# `Spring Cloud用到什么东西？如何实现负载均衡？服务挂了注册中心怎么判断？`
**服务挂了注册中心怎么判断**   
心跳

