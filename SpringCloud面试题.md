# # `Eureka`
##  ## eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？
eureka是AP系统，同时是去中心化的，也就是所有节点都是对等的。
zookeeper是CP系统，中心化的，要进行选举，有learder、follower节点。    
**zookeeper不适合的原因**
zookeeper适合做分布式协服务(比如分布式锁等))，但是做服务发现不是很好，因为服务发现并不需要100%的一直性，很多时候更需要是100%的可用性。zookeeper正在选举时时不对外提供服务的，而且出现网络分区时，这个集群也无法对外提供服务(可读不可写)。

## ## `eureka原理`
蛋疼的开放性问答。。。说实话，这块建议自己看下源代码，这里面其实能深究的地方挺多的。low一点扯一下各个延迟时间。，高端一点可能就要扯下具体实现了。
eureka分为client和Server端。     
### ### `client`
主要用于服务注册和发现的java客户端。   
**`启动阶段：`**
1. 读取配置文件，封装服务注册信息为EurekaClientConfig。
2. 封装当前客户端信息为EurekaInstanceConfig
3. 拉取服务注册表信息并缓存到本地
4. 在Eureka中注册自己(待研究:com.netflix.discovery.DiscoveryClient#register)。
直接请求estApi。
5. 初始化定时任务：续约、心跳、缓存刷新等。

**`应用执行阶段`**
1. 定时发送心跳到EurekaServer注册中心维持注册表的续约。
2. 定时从注册中心拉取注册表信息更新本地注册表。
3. 监控当前应用信息，如果发生改变，则及时在注册中心更新(todo具体怎样需要在研究下)

**`销毁阶段`**
1. 通过rest Api在注册中心注销自己。

### ### `server`
server主要有以下功能：
1. 服务注册
2. 接受客户端的服务心跳
3. 服务剔除
4. 服务下线
5. 集群同步
6. 获取服务注册表中的信息。
#### ####  服务注册原理
直接使用石杉老师总结的图
![avatar](https://s2.ax1x.com/2019/10/13/uxpAHO.jpg)
1. 首先接受到客户端的注册请求，写入到服务注册表，期间会有定时任务来检查心跳。
2. 立即同步到ReadWrite缓存
3. 定时同步到ReadOnly缓存。当客户端拉取服务注册列表时就从此列表拉取。

这样读写分离的原因应该是为了支持高并发。

> https://www.jianshu.com/p/c18db3a2efc6

## ## `eureka集群原理`
Eureka所有节点都是对等，Server在启动过程中会先从其他peer节点拉取注册信息，类似客户端拉取，但是这里的拉取是遍历整个集群，力求最全数据。`在拉取的时候，此server是不可用的，客户端无法请求`。   
为了保证整个集群的一致性，每个Server对本地注册表进行管理时，都会讲对应的所有操作同步到所有peer节点。   
既然涉及到同步，那么就可能存在冲突的问题：eureka通过版本号机制解决(具体我也么没深究过，慢慢研究吧。。)。 

## ## `eureka保护模式`
在网络中可能存在这样一种情况，eureka server与client间形成了分区或者网络一段时间内发生了 异常，所有的服务都没能够进行续约，Eureka Server就把所有的服务都剔除了，这样显然不太合理。所以，就有了自我保护机制，当短时间内，统计续约失败的比例，如果达到一定阈值，则会触发自我保护的机制，在该机制下， Eureka Server不会剔除任何的微服务，等到正常后，再退出自我保护机制。自我保护开关(eureka.server.enable-self-preservation: false)。

## ## `eureka优化`
`关闭保护模式`：在一般的企业内网，网络其实还是比较稳定的，没有必要开启。不过也不是绝对，开启也没问题，毕竟万一出现极端问题了？
### ### 时间优化
1. 客户端拉取注册表信息的时间，默认是30s，但是比较久，个人建议可以改的短一些。
2. 客户端续约时间：默认30s，个人建议改短一些。
3. 服务端刷新ReadOnly缓存的时间，默认30s，个人建议可以改的短一些。
4. 修改服务端默认心跳超时时间：90s
5. 服务端剔除失效节点循环时间：默认60s，也就是一个及节点心跳超时最坏情况，要120秒才会剔除，太久了。60*2s > 90s。


# # `feign\Ribbon`
## ## `你们各个微服务之间的调用时怎么做的？`
feign+ribbon来做微服务之间的交互。feign是rest网络请求客户端，ribbon是负载均衡器组件。

## ## `feign原理`
底层通过动态代理来进行接口请求。

## ## `feign优化`
1. 请求响应压缩，http中的gzip。
2. feign默认采用httpClient，性能不是太好。可以替换Okhttp，性能好一点(网上大佬说的)。

## ## `Ribbon负载均衡`
1. RondomRule: 随机策略。
2. RoundRobinRule：轮询策略。`默认`
3. 响应时间加权策略。响应时间越长，权重越低。
4. RetRule：重试策略。

## ## 如何实现自定义的负载均衡算法？
实现AbstractLoadBalancerRule类

## ## `Ribbon重试策略`
在整合 Ribbon 的情况下，不使用 Feign 重试，而是使用 Ribbon 的重试。
先加入spring-retry依赖，在修改如下配置
```
  ribbon:
    ConnectTimeout: 250 # Ribbon的连接超时时间
    ReadTimeout: 1000 # Ribbon的数据读取超时时间
    OkToRetryOnAllOperations: true # 是否对所有操作都进行重试
    MaxAutoRetriesNextServer: 1 # 切换实例的重试次数
    MaxAutoRetries: 1 # 对当前实例的重试次数
```
https://blog.csdn.net/qq_37334135/article/details/89070588


# # `Hystrix`
## ## `什么是Hystrix?为什么要使用他？`
是一个针对分布式系统容错处理的开源组件，主要用于防止分布式系统的雪崩效应。
![avatar](https://s2.ax1x.com/2019/10/13/uxGuTO.jpg)   
如上图，开始只是库存服务不可用，最终一层层请求堆积，造成了全部服务不可用。而Hystrix就是用来防止此种情况的发生，具有如下功能：
1. 当依赖的服务出现高延迟或者失败时，为系统提供保护和控制。
2. 在复杂的系统中防止级联失败(雪崩效应)。
3. 快速失败的同时能够快速恢复。
4. 提供失败回滚和优雅的服务降级策略。
5. 提供近实时的监控、报警和运维手段。

## ## `什么是服务熔断？`
在分布式系统中，不同服务都是通过接口调用。当服务不可用 时就会发生雪崩效应。为了防止这种情况发生，就需要断路器(类比电路中的断路器)。   
断路器将远程调用包装到一个断路器对象中，用于监控调用过程是否正常。一旦该方法的调用失败次数在一定时间达到了一定阈值，这个断路器就"跳闸了(熔断了)"。在接下来的时间，此接口调用都会直接返回失败，不在进行真实方法调用。从而减少了调用资源消耗，保护了调用者。    
### ### `断路器状态`
**`关闭状态`**
断路器在关闭时，会统计失败次数，在一段时间内达到一定阈值就会打开。

**`打开状态`**
断路器打开会直接返回异常，不会真正进行方法调用。

**`半开状态`**
当然，异常的服务可能在一定时间后恢复正常，所以断路器要有恢复策略。这策略就是半开状态。断路器可以设置一个重置时间，在重置时间结束时，断路器将转换为半开状态。    
处于半开状态时，会允许一定量的请求进行真实调用，当成功数量达到一定阈值时就会关闭断路器。否则重新进入关闭状态。

## ## `什么是服务降级？`
服务降级就是，当某个依赖的服务不可用时，对着依赖的服务进行降级。比如：订单服务在订单确认收货成功后需要调用积分服务进行积分增加，但是此时积分服务不可用，那么可以做降级策略，放弃直接调用积分服务，而是采取向数据库写入一条积分增加信息，等积分服务恢复时，积分服务会自动去读取这部分数据，这就是降级。    
Hystrix的降级策略和熔断策略类似：当调用失败达到一定阈值，断路器打开，调用快速失败，直接走Fallback逻辑(降级逻辑)。

## ## `Hystrix底层原理？`
1. Hystrix将远程调用逻辑封装为`HystrixCommand`, 这些远程调用将会在独立的线程中执行，使用了命令模式。

## ## `Hystrix配置`
1. 超时时间，默认1s。
2. 线程池核心线程数：10

# # `zuul`
## ## `什么是zuul？为什么要用zuul？`
zuul是网关组件。类似于Nginx。相比nginx，主要优点是配置注册中心实现动态路由，同时即开即用。主要功能：
1. 认证和授权
2. 压力控制
3. 金丝雀测试
4. 动态路由
5. 主动流量管理(限流)

## ## `Zuul重试策略`
```
zuul:
    retryable: true # 开始重试
ribbon：
    MaxAutoRetries：1 # 同一个服务重试的次数(除去首次)
    MaxAutoRetriesNextServer: 1 # 切换相同服务数量
```

## ## `Zuul原理？`
Zuul的核心是Filter责任链。

## ## Zuul filter类别？

zuul中定义了四种不同生命周期的过滤器类型

1. pre： 可以在请求路由之前调用
2. route：在路由请求时候被调用
3. post：在rote和error过滤器后被调用
4. error： 处理请求时发生错误时被调用。

可以用过指定`fiterOrder`的int值来定义过滤器的执行顺序。

## ## `如何做限流？`
限流使用的最多的就是漏桶和令牌。    
**令牌**   
令牌以一定速率生产放入到令牌容器中，然后请求时需要获取令牌才能发送请求，如果失败则拒绝。guava包中貌似有现成的。

**漏桶**    
吧发送请求放到一个固定大小的桶中，请求完成就移除。如果桶满了就直接拒绝。可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。


zuul可以结合Redis来做限流。zuul有三方开源的限流库。

# `Spring Cloud用到什么东西？如何实现负载均衡？服务挂了注册中心怎么判断？`
**服务挂了注册中心怎么判断**   
心跳

# `微服务你们监控怎么做的？`
**`简易版`**      
Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。同时也可以结合Eureka监控整个集群的信息，如果需要发邮件的话，直接加上mail的依赖

