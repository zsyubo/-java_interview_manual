#  #`索引是什么？ `

是一种帮助mysql高效获取数据的`排好序的数据结构`，同时索引存储在文件中。

#  #`mysql存储引擎？ ` ,`为什么InnoDB表要建议用自增列做主键而MyISAM不需要`
![avatar](https://s2.ax1x.com/2019/09/19/nO3lRA.png)
表级别

innoDB：必须有主键。主键索引是聚集索引，索引和数据是一块的，查询更快。非聚集索引：叶子节点存主键id，更易保证索引一致性。
![avatar](https://s2.ax1x.com/2019/09/19/nO3lRA.png)
MYIsam：索引、数据文件分离。主键索引和非主键索引存储是差不多的，都是先查询索引文件，在查数据文件。

# #`为什么不用uuid `
uuid是一个长字符串，比较占用索引空间。
同时不好做范围查询。
不是连续插入(更多的磁盘io，毕竟不是立马写入，都是写缓存区在刷盘？)，性能不行

# #`mysql分页有什么优化 `
1. 如果需要排序，使用主键索引排序
2. 能使用覆盖查询最好用覆盖查询。
3. 最好limit和where 条件都走索引。

#  #`悲观锁、乐观锁 `
mysql乐观锁 可以使用 版本号来做。    
悲观锁其实就是独占资源，如果一个事务修改了一条数据并未提交，那么其他事务修改此数据就会阻塞等待。

#  #`组合索引，最左原则，组合索引底层原理?` 

在表中的多个字段上创建的索引，使用联合索引遵循最左匹配原则。在进行查询是，对于组合索引会从 组合索引的最左边索引列进行匹配。`同时对于联合索引，mysql只会匹配到范围查询`，也就是 如果  where a= xx  b =xx  c<> 0 d=x ,那么此联合索引(abcd)不会匹配d.如果是abdc则可以，同时mysql会对联合索引的条件进行排序。

**底层原理**
其实就是B+树的特性。
![](https://s2.ax1x.com/2019/10/13/uj3cCR.jpg)
，底层多列存储，`最下面的时间应该是主键，暂时不纠结`。

#  #`索引是不是建立的越多越好`
不是，在where条件中，只会走一个索引，所以更多考虑联合索引。此有B+数特性决定。

#  #`聚集索引和非聚集索引的区别`
一个表只能有一个聚集索引，因为决定了物理排序顺序。集索引叶子节点存放表中的所有数据记录的信息，也就是数据即索引。   
非聚集索引是普通索引，普通索引只会在叶子节点保存自己本身的键值与主键的值。
![](https://s2.ax1x.com/2019/10/13/uj34bD.jpg)

# #`mysql 的表锁、行锁` 
表锁直接对表加锁：lock table  表明  read/write;  读锁只能读，不能写。    
行锁对一行加锁：行锁分为读锁(select ..... lock in share mode,只能读)，写锁、间隙锁(范围查询)、意向锁和MDL锁(修改表数结构)     
当事务a获取了一条数据的行锁，当事务b获取表写锁是就会与刚才的行锁冲突，这时候事务b肯定是要阻塞的。如果事务b怎么知道表中哪一行获取到了锁了？这时候就有了意向锁的概念，当事务a需要取得行级锁时，会先申请意向锁（表锁），当事务b申请表锁时就会阻塞

# #`mysql的索引分类：B+，hash；什么情况用什么索引`
todo

#  #`事务的特性和隔离级别`
`原子性(Atomicity)`也就是原子操作，一个事务内sql语句要么全部提交成功，要么全部提交失败。    
`一致性(Consistency)` 一致性是指数据库中的数据在事务操作前和事务处理后必须满足业务规则约束。     
比如转账， A扣100，b加100。一致性的情况下，在事务提交后不可能出现，a扣了100，但是b并没有加100。    
`隔离性(Isolation)`就是数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行导致数据的不一致。    
`持久性(Durability)`事务处理结束后，对数据的修改就是永久的，即便系统发生故障也不会丢失。   

#  #`InnoDB隔离级别？`
 读未提交 （read-uncommitted）， READ-COMMITTED 读已提交，READ-COMMITTED 可重复读 mysql默认级别，串行化（serializable）。不做详细解释了，估计大多人都能背下来了。


#  #`InnoDB可重复读会存在幻读问题么？`
RR隔离级别只能部分解决幻读，特殊情况还是存在。        
MySQL可以通过加锁来防止幻读的出现，这种锁定通过Next-key机制来实现，是属于记录锁和间隙锁(Gap锁)的结合。 比如事务A修改一个范围，同时事务B插入的数据刚好在范围内，就会阻塞。       
按照可重复读的简单定义和保证机制，会有幻读产生。但是实际的情况是MySQL用gap锁,next-key机制防止在可重复读的隔离级别下产生幻读。
https://www.jianshu.com/p/4e102e55d7de

# #`ACID原理`
`只是简略的写下，里面的内容太多了。`
整个ACID中其实主要就是为了一致性，AID都是为了一致性来服务。
- A：利用Innodb的ubdo log（回滚日志），会记录DML(数据操作语句)，这些其实就是要回滚的信息。
- D： 利用Mysql的Redo log,mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，在刷回磁盘。在刷盘的过程中可能出现宕机的问题，虽然可以通过在事务提交前先吧数据刷到磁盘，但是这样性能并不太好，mysql是会先在redo log 中记录这次操作，在事务提交时，会将redo log 日志进行刷盘，如果突然当即，mysql会先将redo log中的内容进行恢复，在更具 undo log 和binlog中的内容决定回滚数据还是提交数据。
- I:利用所和MVCC机制。至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在undo log中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。 由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同，就不赘述了。

> 为什么需要两个日志了：因为做追加操作最快。。合在一起，需要在文件里一直来回移动。。写入速度太慢。

#  #`为什么要要用B+tree？`
https://mp.weixin.qq.com/s/GyWhgvsWEkhVcx6P6VsHvw

- 红黑树：数据量大，深度也大。同时对数据进行范围查询时不太友好。
- Hash：hash碰撞，扩容？
- B+tree：相对于红黑树，高度可控，减少磁盘IO。相对于B树，对范围查询(顺序查询)做了优化。Btree由于节点存储数据，所以每个节点不可能太大，每一页数据才几kb(`没完全理解，可能是错的，以后在更新`)
![avatar](https://s2.ax1x.com/2019/10/13/uj8SaQ.jpg)

## ## 顺便说下B+tree的特性
- 非叶子节点不存储data，只存储key(缩减度,飞叶子节点能存储更多的节点)。
- 叶子节点不存储指针
- 顺序访问指针，提高区间访问的性能。

## ## 拓展
InnoDB存储引擎最小储存单元——页（Page），一个页的大小是16K（默认值可修改）。一般系统最小文件是4kb(macos)    
假设一行数据1k，那么一个也可以存放16行这样的数据(b tree)，但是这样太慢了，如果一次查询过多数据，那么就会查询很多页，索引引入了B+ tree，这样非叶子节点存放更多键值+指针，避免查询很多页，减少磁盘io。     
所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。



# `Binlog日志是什么？`

todo

# mysql 5.7新特性说一下？

- Innodb存储引擎的增强:
  - 性能提高
  - 5.7以前不支持索引的重命名，5.7支持
  - 支持为Innodb建立表空间。
  - 支持在线修改innodb_buffer_pool`(innodb缓存)大小
- 服务端的安全性
  1. 初始化的改变(安全性)：安装完成会为root@localhost用户提供一个默认密码，5.7之前密码是空的。第一次进入mysql命令行，强制修改密码，否则无法进行其他操作。
  2. 增加了自动过期策略，密码过期之后必须强制修改。同时增加了用户锁定配置。
- 易用性
  - 可以explain一个正在运行的sql。
  - performance_schema提供了更多的监控信息，包括内存使用、MDL锁、存储过程等。
- 复制功能增强
  - 多源复制：支持由多个master向一个slave复制。用于将多个服务器备份到单个服务器上。可用于异地容灾和集中备份。

# ` MYSQL 有哪些主从复制方案，你们线上怎么使用的？`

一般常用的主从方案是：单向主从、级联主从、一主多从、多主一从(5.7支持)。

**复制方案**

1. 异步复制

   默认的复制方法，原理简单，就是主库写binlog日志后立即返回客户端，无需等待binlog日志传递给从库的过程。`缺点很明显：主库发送宕机，可能出现丢失数据的情况。`

2. 半同步复制

   主服务器需要安装半同步复制插件，才能开启复制功能。在该功能下：确保从库接收完库传递过来的binlog内容已经写入到relay log里面了，才会通知主库上面的等待线程。当然会有一个等待超时时间，如果超过超时时间，会转为异步复制，`直到至少有一台从库通知主库已经接收到binlog信息为止`。

3. GTID复制

   GTID又叫全局事务iD，是一个已提交事务的编号，并且是全局唯一，Mysql5.6支持。

   GTIP使用master_auto_position=1代替了基于binlog和position号的主从复制搭建方式。

4. todo



# `说一下搭建主从的大概流程？`

前提：主库的`server-id=1323306`，从库的	`server-id=1333306`不一致。主库开启binlog功能。

1. 在主库上创建一个主从复制的账户。
2. 初始化数据，同时让从库与主库在某一位置达到同步。建议直接冷备份或者直接导出完整sql。
3. 把主从的数据导入到从库。从库进行数据恢复
4. 在从库配置同步参数
5. 在从库上执行主从命令。`start slave;`ok，主从配置就搞定了。`同时从库一般会开启read only`，防止误操作从库。

查看主从状态：`show slave status\G;`

**如果主库更新数据，从库找不到的而报错**

通过`show slave status\G;`可以查看到具体的错误状态。如果只是少量可以周到是那条漏执行的sql，只需要在从库在执行一次就行了。如果批量的话，建议重新做一次同步。

# # ` MYSQL 的主从延迟怎么解决。`
todo
mysql支持半同步复制（必须有一个 从节点写入成功）+并行复制;

**主从复制原理**

主服务器有一个工作线程I/O dump thread，从服务器有两个工作线程，一个是I/O thread，另一个是SQL thread。

1. 主库把外界接受的SQL请求记录到自己的binlog日志中。(也就是主库通过I/O dump thread 给从库 I/O thread传送binlog日志)。
2. 从库的I/O thread 去请求主库的binlog日志，并将得到的binlog日志写到自己的Relay log(中继日志)文件中。
3. 从库`重放`中继日志中得到的SQL语句。

<img src="https://s2.ax1x.com/2019/10/22/KG2aKf.png" style="zoom:30%;" />

# Mysql 主从一致性你们是怎样的方案？

一般基于row+GTID的方式不会出现不一致的情况，非常情况比如：主库从库异常断电、磁盘出现写超时情况、进程崩了或被kill掉了。

在5.7+row+GTID+增强半同步基本不会出问题。必要的话可以通过工具来检测不一致的情况

> [MySQL主从数据一致性校验及修复](https://www.jianshu.com/p/27f790f26419)

# Mysql 冷备、热备？

`冷备`是在数据库处于关闭状态下的备份，好处是可以保证数据库的完整性，备份过程速度快一些。`备份`其实就是在mysql关机状态将mysql的数据文件拷贝一份。`恢复`过程也很简单：仅仅需要把已备份的数据目录替换原有的目录就行了。

`热备`主要用两种：一种是直接裸文件备份(依赖第三方工具)，一种是逻辑备份，逻辑备份也就是sql备份，一般的工具有：mysqldump、select。。。into outfile、mydumper。

# #`数据库会死锁吗，举一个死锁的例子， mysql 怎么解决死锁。`
会，但是mysql会自动检测死锁，如果发生了死锁，mysql会随机选取一个小型事务抛出异常并回滚。

# #`Binlog 结构`
todo

# #`Mvcc`
至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在undo log中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。 由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同，就不赘述了。

# #`mysql 性能优化 `
一般性能优化都是针对查询速度，而查询速度则有两方面，一个是sql，一个是数据量。       
如果一个表数据量太多（个人觉得500w，同时每天数据量增加迅猛），那么考虑分库分表，同时考虑对sql进行优化。     
sql优化第一步对表的合理设计，比如表字段不宜过多，表字段精良避免null。        
接下来是索引，当然索引不是越多越好，应结合业务：对重复度低，经常查询的列来设置索引，最好设置唯一索引或组合索引。同时索引设计合理：重复度低，经常查询、用于表连接、字段数据不大、为NUll。    
对一条sql优化可以使用explain命令：先看type：如果为all则是全表扫描，同时也没必要继续看了。为ref则为走索引。    
index的情况：select * from xxx，其中所有字段都加了索引。
看key列：是否用到了索引       
看row列：该列的扫描行数（预期）。    
Extra：执行情况的描述和说明

# # `怎么优化 table scan 的。`
Sql语句应该劲量避免全表扫描。如下一些案例：
1. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。    
1. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
3. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描(用in替代)。
4. in 和 not in 也要慎用，否则会导致全表扫描,特别是in中太多条件了。
5. `%%`查询，使用全文检索。
6. 。。。。。。。。。。很多：https://blog.csdn.net/riemann_/article/details/90453787

# #`分库分表：垂直拆分和水平拆分?`
**垂直拆分**
一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面
**水平拆分**
垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。也是吧数据拆分到不同库。

# # `列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题` 
# # `你们分库分表怎么做的?`
# # `如果是Mycat，那么他的原理是什么?` 
Mycat是分库分表的中间件，通过Mycat可以很简单的完成分库分片和主从。
![](https://s2.ax1x.com/2019/10/13/ujGK0S.jpg)
## ## 概念
1. Schema：逻辑库，与MySQL中的Database（数据库）对应，一个逻辑库中定义了所包括的Table。 
2. Table：逻辑表，即物理数据库中存储的某一张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode。在此可以指定表的分片规则。 
3. DataNode：MyCAT的逻辑数据节点，是存放table的具体物理节点，也称之为分片节点，通过DataSource来关联到后端某个具体数据库上 
4. DataSource：定义某个物理库的访问地址，用于捆绑到Datanode上

**`分片规则：`**：前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难。    
**分片规则很多**
1. 时间类：按天分片、自然月分片、单月小时分片
2. 哈希类：Hash固定分片、日期范围Hash分片、截取数字Hash求模范围分片、截取数字Hash分片、一致性Hash分片
3. 取模类：取模分片、取模范围分片、范围求模分片
4. 其他类：枚举分片、范围约定分片、应用指定分片、冷热数据分片
## ## 查询原理
Mycat的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的SQL语句，首先对SQL语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。    
查询如果条件是分片字段，那直接根据规则查询对应的DataNode，如果不是，那么就是分发给全部DataNode。
**简单案例分析**
```
select * from xxxx limit  20;
```
mysql会先进行拆分，这种简单的mycat会直接在每一个DataNode中执行，然后把执行后获得的数据进行聚合在一起，对其进行最小堆运算，然后发送给客户端。

## ## 缺点
配置太复杂了。。。同时join老问题。优点就是中间层，不耦合代码。

# #`show warnings`
在进行explain时，可以在后面再加一句` show warnings;`可以显示由上一个生成消息的语句导致的错误、警告和注意消息。一般可用来查看mysql优化生成的语句。    
https://blog.csdn.net/afsvsv/article/details/84998119

# `Sql执行顺序？`
1. from 
2. join 
3. on 
4. where 
5. group by(开始使用select中的别名，后面的语句中都可以使用)
6. avg,sum.... 
7. having 
8. select 
9. distinct 
10. order by 
每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。 

# `where子查询会生产虚拟表么？`


# `关于一些简单的SQL笔试题`
```
#(2)
SELECT * FROM S 
WHERE s_id IN(
	SELECT s_id FROM SC
		GROUP BY s_id HAVING COUNT(*)=(SELECT COUNT(*) FROM C)
);
#(3)
select * from S
where s_id in (
	select s_id from SC 
		group by s_id having count(*) >= 2
);
```

[学生表S，课程表C，学生课程表SC](https://blog.csdn.net/qq_22771739/article/details/88121967)

[MySQL全方位练习（学生表 教师表 课程表 分数表）](https://www.cnblogs.com/mzhaox/p/11280234.html)

