# `CAP、BASE理论`
**CAP**    
CAP理论是学术上分布式计算领域的公认定理，CAP理论告诉我们，一个分布式系统（指互相连接并共享数据的节点的集合）中不可能同时满足一致性(C:Consistency)、可用性(A:Availability)、分区容错性(P:Partition tolerance)这个三个需求，最多只能满足2个。 

**BASE**    
其实实际应用中，存在网络延迟的情况，所以一致性都是最终一致性，而BASE理论就是基于AP,但是没有放弃C，而是采取了牺牲故障时的一致性，达到最终的一致性。
- 基本可用(BA)
基本可用是指分布式系统出现不可预知故障的时候，允许损失部分可用性、保证系统可用,比如：
  - 响应时间上的损失
  - 功能上的损失 比如:购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。
- 弱状态(S)
也称软状态，和硬状态相比，允许系统中的数据存在中间状态，并认为不会影响系统可用性，及允许系统在不同节点之间的数据副本之间进行数据同步的过程存在延时。
- 最终一致性(E)
最终一致性是指系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不需要强一致性。最终就是指不管多少时间，总会达到一致性状态。

# `天天说分布式微服务，你明白什么是分布式么?`
字面意义上，就是一个服务分布在不同的主机上，彼此通过消息通信或者RPC调用。  
**为什么需要分布式了？**    
单机性能总会有瓶颈的，到达瓶颈时要么提高服务器配置、改造项目为分布式、负载均衡。当然提高配置一般比较少做，毕竟越高的配置会花越多的钱，同时也会存在单点故障。
**分布式完美无缺么？**
肯定不是啦，
1. 单点问题，可以使用高可用集群解决，如果是中心化的集群则还需要考虑选主问题。
2. 服务依赖过于复杂：这也是一个问题，在复杂的分布式项目中，一个业务可能依赖数10个其他服务，这是开发协调、测试将会变得异常麻烦，毕竟要和别人沟通。
3. 服务雪崩问题：当分布式调用链某一环节出现异常时，都会导致整个调用链路等崩坏，解决方案是：服务降级、服务熔断。

# `集群、分布式、负载均衡`
`集群`：同一个业务，部署在多个服务器上。    
`分布式`：一个业务分拆成多个子业务，或者本身就是不同的业务，部署在不同的服务器上。　   
`负载平衡`是一个应用是利用多台服务器提供单一服务。
`负载均衡更多指的是一种算法、策略。`

# `什么是微服务？为什么要使用微服务了？`
微服务是一种架构架构模式。提倡将一个大型应用拆分为一组小的服务(细粒度)，每个服务间相互协调，运行在独立的进程中，通过轻量级的方式通信。
**微服务该多小了？**
一般来说，一个微服务就是一个独立的业务，比如商城中的商品服务。当然也可以更小，比如业界常说的只做一件事：比如发邮件、短信。
<!-- 你看不到我看不到我 -->
**微服务一般有哪些组件：**
服务治理：服务注册、服务发现 
服务容错：熔断、限流、降级 
服务网关 
配置中心 
链路追踪


# `微服务、SOA的区别？`
**SOA**
SOA是一个很宽泛的概念。SOA代表面向服务的架构：也就是将大型应用分成多个模块，中间通过接口来进行通信。传统SOA一般有两种实现方式:webService和ESB。同时SOA是按模块拆解为子系统，粒度更大些。    
**`区别`**
微服务的理念和SOA差不多,可以说微服务是SOA的子集，但是我们一般说SOA更多指的的传统的应用(ESB、webService），而微服务是面向现代化。同时SOA的粒度更大、更笨重、集成方式更加复杂。    
但是微服务是划分成一个独立自治的服务，粒度也更细。同时微服务更加轻量级。    
同时微服务提供了了一系列组件来让微服务更加容易的落地，比如服务注册、服务发现、服务容错、限流、降级、配置中心。

# `QPS、TPS？` 
`QPS：Queries Per Second意思是“每秒查询率”`，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。     
`TPS：是TransactionsPerSecond的缩写，也就是事务数/秒`。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

# `Dubbo的底层实现原理和机制` 

# `描述一个服务从发布到被消费的详细过程 `

# `分布式系统怎么做服务治理` 
采用注册中心来进行服务治理。

# `接口的幂等性的概念 `
一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如创建一个订单，我连续重复点了多次，不能直接给我创建多个订单。

# `消息中间件如何解决消息丢失问题`
消费是ack机制,如果因为其他原因导致消费失败会触发mq的重试策略，保证消费端收到并成功处理数据。

发送时采用同步发送，会有返回值。

# `Dubbo的服务请求失败怎么处理`

# `重试机制会不会造成错误` 
在幂等的情况下不会。

# `什么是一致性了，谈谈你对一致性的理解`

同场景下 一致性 的规则并不相同。换句话说，一致性指的就是最终的结果是否和设定的规则保持一致！可以从ACID、CAP到分布式事务。其实都是为了一致性而服务。

# `对分布式事务的理解` 

2PC、3PC、TCC、最终一致性。。。。。。。。。。这里不细说了。

# `如何实现负载均衡，有哪些算法可以实现？` 
轮询、随机、LRU（java可通过LinkedHashMap）

# `Zookeeper的用途，选举的原理是什么？` 

# `数据的垂直拆分水平拆分。` 

# `zookeeper原理和适用场景 `

# `zookeeper watch机制` 

# `redis/zk节点宕机如何处理 `

# `分布式集群下如何做到唯一序列号` 

# `如何做一个分布式锁 `
使用redis的setnx命令进行实现，1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。解锁使用Lua脚本
```
"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
```
解锁需要判断是否是自己加锁，加锁时需要传递一个参数，将该参数作为这个 key 的 value，这样每次解锁时判断 value 是否相等即可。

所以解锁代码就不能是简单的 del了。


# `zookeeper的选举策略` 

# `全局ID`

