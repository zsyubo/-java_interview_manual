# `微服务、SOA的区别？`
SOA代表面向服务的架构：也就是将大型应用分成多个模块，中间通过接口来进行通信。SOA一般有两种实现方式:webService和ESB。       
微服务的理念和SOA差不多，微服务也是提倡将大型应用划分成一组小的服务(根据业务拆分)。每个服务间互相独立，不共享数据库。各个服务之间采用轻量级的方式进行通信。   

**区别**    
SOA划分的是模块，但是微服务是划分成一个独立自治的服务，粒度也更细。同时微服务更加轻量级。

同时微服务提供了了一系列组件来让微服务更加容易的落地，比如服务注册、服务发现、服务容错、限流、降级、配置中心。

# `QPS、TPS？` 
`QPS：Queries Per Second意思是“每秒查询率”`，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。     
`TPS：是TransactionsPerSecond的缩写，也就是事务数/秒`。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

# `Dubbo的底层实现原理和机制` 

# `描述一个服务从发布到被消费的详细过程 `

# `分布式系统怎么做服务治理` 

采用注册中心来进行服务治理。

# `接口的幂等性的概念 `

一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如创建一个订单，我连续重复点了多次，不能直接给我创建多个订单。

# `消息中间件如何解决消息丢失问题`

消费是ack机制,如果因为其他原因导致消费失败会触发mq的重试策略，保证消费端收到并成功处理数据。

发送时采用同步发送，会有返回值。

# `Dubbo的服务请求失败怎么处理`

# `重连机制会不会造成错误` 

在幂等的情况下不会。



# `什么是一致性了，谈谈你对一致性的理解`

同场景下 一致性 的规则并不相同。换句话说，一致性指的就是最终的结果是否和设定的规则保持一致！可以从ACID、CAP到分布式事务。其实都是为了一致性而服务。

# `对分布式事务的理解` 

2PC、3PC、TCC、最终一致性。。。。。。。。。。这里不细说了。

# `如何实现负载均衡，有哪些算法可以实现？` 

轮询、随机、LRU（java可通过LinkedHashMap）

# `Zookeeper的用途，选举的原理是什么？` 

# `数据的垂直拆分水平拆分。` 

# `zookeeper原理和适用场景 `

# `zookeeper watch机制` 

# `redis/zk节点宕机如何处理 `

# `分布式集群下如何做到唯一序列号` 

# `如何做一个分布式锁 `

使用redis的setnx命令进行实现，1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。解锁使用Lua脚本

`"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";`

解锁需要判断是否是自己加锁，加锁时需要传递一个参数，将该参数作为这个 key 的 value，这样每次解锁时判断 value 是否相等即可。

所以解锁代码就不能是简单的 del了。

# `列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题` 

# `zookeeper的选举策略` 

# `全局ID`

