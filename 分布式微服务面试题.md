# `CAP、BASE理论`
**CAP**    
CAP理论是学术上分布式计算领域的公认定理，CAP理论告诉我们，一个分布式系统（指互相连接并共享数据的节点的集合）中不可能同时满足一致性(C:Consistency)、可用性(A:Availability)、分区容错性(P:Partition tolerance)这个三个需求，最多只能满足2个。 

**BASE**    
其实实际应用中，存在网络延迟的情况，所以一致性都是最终一致性，而BASE理论就是基于AP,但是没有放弃C，而是采取了牺牲故障时的一致性，达到最终的一致性。
- 基本可用(BA)
基本可用是指分布式系统出现不可预知故障的时候，允许损失部分可用性、保证系统可用,比如：
  - 响应时间上的损失
  - 功能上的损失 比如:购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。
- 弱状态(S)
也称软状态，和硬状态相比，允许系统中的数据存在中间状态，并认为不会影响系统可用性，及允许系统在不同节点之间的数据副本之间进行数据同步的过程存在延时。
- 最终一致性(E)
最终一致性是指系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不需要强一致性。最终就是指不管多少时间，总会达到一致性状态。

# `天天说分布式微服务，你明白什么是分布式么?`
字面意义上，就是一个服务分布在不同的主机上，彼此通过消息通信或者RPC调用。  
**为什么需要分布式了？**    
单机性能总会有瓶颈的，到达瓶颈时要么提高服务器配置、改造项目为分布式、负载均衡。当然提高配置一般比较少做，毕竟越高的配置会花越多的钱，同时也会存在单点故障。
**分布式完美无缺么？**
肯定不是啦，
1. 单点问题，可以使用高可用集群解决，如果是中心化的集群则还需要考虑选主问题。
2. 服务依赖过于复杂：这也是一个问题，在复杂的分布式项目中，一个业务可能依赖数10个其他服务，这是开发协调、测试将会变得异常麻烦，毕竟要和别人沟通。
3. 服务雪崩问题：当分布式调用链某一环节出现异常时，都会导致整个调用链路等崩坏，解决方案是：服务降级、服务熔断。

# `集群、分布式、负载均衡`
`集群`：同一个业务，部署在多个服务器上。    
`分布式`：一个业务分拆成多个子业务，或者本身就是不同的业务，部署在不同的服务器上。　   
`负载平衡`是一个应用是利用多台服务器提供单一服务。
`负载均衡更多指的是一种算法、策略。`

# `什么是微服务？为什么要使用微服务了？`
微服务是一种架构架构模式。提倡将一个大型应用拆分为一组小的服务(细粒度)，每个服务间相互协调，运行在独立的进程中，通过轻量级的方式通信。
**微服务该多小了？**
一般来说，一个微服务就是一个独立的业务，比如商城中的商品服务。当然也可以更小，比如业界常说的只做一件事：比如发邮件、短信。
<!-- 你看不到我看不到我 -->
**微服务一般有哪些组件：**
服务治理：服务注册、服务发现 
服务容错：熔断、限流、降级 
服务网关 
配置中心 
链路追踪

# `微服务、SOA的区别？`
**SOA**
SOA是一个很宽泛的概念。SOA代表面向服务的架构：也就是将大型应用分成多个模块，中间通过接口来进行通信。传统SOA一般有两种实现方式:webService和ESB。同时SOA是按模块拆解为子系统，粒度更大些。    
**`区别`**
微服务的理念和SOA差不多,可以说微服务是SOA的子集，但是我们一般说SOA更多指的的传统的应用(ESB、webService），而微服务是面向现代化。同时SOA的粒度更大、更笨重、集成方式更加复杂。    
但是微服务是划分成一个独立自治的服务，粒度也更细。同时微服务更加轻量级。    
同时微服务提供了了一系列组件来让微服务更加容易的落地，比如服务注册、服务发现、服务容错、限流、降级、配置中心。

# `QPS、TPS？` 
`QPS：Queries Per Second意思是“每秒查询率”`，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。     
`TPS：是TransactionsPerSecond的缩写，也就是事务数/秒`。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。


# `Dubbo是什么？解决了什么问题？`
Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC（一种远程调用） 分布式服务框架（SOA），致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。具有性能高、已使用和可拓展性强等特点。

**dubbo中的各种角色**     
<img src="https://s2.ax1x.com/2019/10/14/uzy3DO.jpg"  width="500" height="300" />

1. provide： 暴露服务的提供方
2. consumer：调用服务的服务消费放
3. registry： 服务注册与发现的注册中心。
4. monitor：统计服务调用次数和调用时间的监控中心。
5. container：服务运行容器。

**`dubbo支持的协议：`**
1. dubbo://
2. http://
3. rest://
4. redis://
5. memcached://
6. multicast://
7. nacos://

# `Dubbo的底层实现原理和机制` 
![](https://img-blog.csdnimg.cn/2019050810072764.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VuX2pva2Vy,size_16,color_FFFFFF,t_70)

1. client一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo是使用AtomicLong从0开始累计数字的
2. 将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象callback，全部封装在一起，组成一个对象object
3. 向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object)
    将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去
4. 当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用synchronized获取回调对象callback的锁， 再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。
5. 服务端接收到请求并处理后，将结果（此结果中包含了前面的ID，即回传）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果，取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。
6. 监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放callback的锁了），再notifyAll()，唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了），至此，整个过程结束。


# `Dubbo的SPI机制` 

# `Dubbo有哪些配置项？`
| **标签** | **用途** | **解释** | 
|:----|:----|:----|
| &lt;dubbo:application/>   | 公共 | 用于配置当前应用信息，不管该应用是提供者还是消费者 | 
| &lt;dubbo:registry/> | 公共 | 用于配置连接注册中心相关信息 | 
| &lt;dubbo:protocol/> | 服务 | 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受 | 
| &lt;dubbo:service/> | 服务 | 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 | 
| &lt;dubbo:provider/> | 服务 | 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选 | 
| &lt;dubbo:consumer/> | 引用 | 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选 | 
| &lt;dubbo:reference/> | 引用 | 用于创建一个远程服务代理，一个引用可以指向多个注册中心 | 
| &lt;dubbo:method/> | 公共 | 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息 | 
| &lt;dubbo:argument/> | 公共 | 用于指定方法参数配置 | 


# `Dubbo超时时间和重试配置？配置优先级问题`
dubbo官方推荐：`在 Provider 端尽量多配置 Consumer 端属性`
**重要的配置项**
```
 <dubbo:method name="findAllPerson" timeout="10000" retries="9" loadbalance="leastactive" actives="5" />

```
- timeout: 方法调用超时时间
- retries： 失败重试次数，缺省是2。表示加上第一次调用，会调用 3 次
- loadbalance：负载均衡算法，缺省是随机random。可以配置轮询 roundrobin、最不活跃优先 [4] leastactive 和一致性哈希 consistenthash 、RoundRobin LoadBalance（权重轮询均衡算法）。
- 消费者端的最大并发调用限制，即当 Consumer 对一个服务的并发调用到上限后，新调用会阻塞直到超时，在方法上配置 dubbo:method 则针对该方法进行并发限制，在接口上配置 dubbo:service，则针对该服务进行并发限制





# `描述一个服务从发布到被消费的详细过程 `

# `分布式系统怎么做服务治理` 
采用注册中心来进行服务治理。

# `接口的幂等性的概念 `
一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如创建一个订单，我连续重复点了多次，不能直接给我创建多个订单。

# `消息中间件如何解决消息丢失问题`
消费是ack机制,如果因为其他原因导致消费失败会触发mq的重试策略，保证消费端收到并成功处理数据。

发送时采用同步发送，会有返回值。

# `Dubbo的服务请求失败怎么处理`

# `重试机制会不会造成错误` 
在幂等的情况下不会。

# `什么是一致性了，谈谈你对一致性的理解`

同场景下 一致性 的规则并不相同。换句话说，一致性指的就是最终的结果是否和设定的规则保持一致！可以从ACID、CAP到分布式事务。其实都是为了一致性而服务。

# `对分布式事务的理解` 

2PC、3PC、TCC、最终一致性。。。。。。。。。。这里不细说了。

# `如何实现负载均衡，有哪些算法可以实现？` 
轮询、随机、LRU（java可通过LinkedHashMap）

# `Zookeeper的用途，选举的原理是什么？` 

# `数据的垂直拆分水平拆分。` 

# `zookeeper原理和适用场景 `

# `zookeeper watch机制` 

# `redis/zk节点宕机如何处理 `

# `分布式集群下如何做到唯一序列号` 

# `如何做一个分布式锁 `
使用redis的setnx命令进行实现，1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。解锁使用Lua脚本
```
"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
```
解锁需要判断是否是自己加锁，加锁时需要传递一个参数，将该参数作为这个 key 的 value，这样每次解锁时判断 value 是否相等即可。

所以解锁代码就不能是简单的 del了。


# `zookeeper的选举策略` 

# `全局ID`

