# `你说你熟悉并发编程，那么你说说Java锁有哪些种类，以及区别`

# `如何保证内存可见性`

# `synchronized 的实现原理以及锁优化？ `
底层字节码是在同步代码块两边加入monitorenter 和 monitorexit 指令。
每一个对象都有一个监视器(monitor)想关联(对象头指向)。当且一个Monitor被持有后，它将处于锁定状态。monitor对象记录了持有锁的线程信息等

https://www.cnblogs.com/ZoHy/p/11313155.html

在jdk1.6中对synchronized做了很大的优化，比如锁升级、锁粗化、锁清除。

锁升级比较重要：第一个偏向锁(直接CAS替换对象头的Mark Word)，轻量级锁(自旋)，如果还失败就是重量级锁。



#  `volatile 的实现原理？` 

volatile 主要是为了可见性和有序性(防止重排序)，可见性原理是缓存一致性，volatile是通过内存屏障和禁止重排序来保证可见性的。 禁止重排序主要就是内存屏障。此指令除了禁止重拍，同时还会将线程内存数据写会到主存。

#  `happen-before原则` 
todo

# `Java 的信号量？ `

Semaphore,用来限制同时访问某特定资源的操作数量，底层是采用AQS+ConditionObject

# `synchronized 在静态方法和普通方法的区别？ `

锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁,

锁是当前实例对象 ，进入同步代码前要获得当前实例的锁



# `怎么实现所有线程在等待某个事件的发生才会去执行？`

CountDownLatch或者CyclicBarrier。

# `CAS？CAS 有什么缺陷，如何解决？` 

CAS是比较替换，是乐观锁，一般有3个参数，v内存值，E预期值，N要替换的值，当V=E时，替换V为N。缺陷是ABA问题AtomicStampedReference，底层是通过版本号

```
Pair<T> {

        final T reference;

        final int stamp;

```

# `synchronized 和 lock 有什么区别？` 

一个底层JVM实现，通过monitor，加锁解锁不需要自己去控制。一个AQS实现。Lock更轻量级一些，同时ReentrantLock支持公平锁。

# `Hashtable 是怎么加锁的 ？` 

直接用synchronized包裹

#  `HashMap 的并发问题？` 

集合类，但是在多线程情况下会有并发安全问题，主要是Rehash时会出现问题，当HashMap容量达到负载因子是就会扩容，扩容简单说有两步

1. 创建一个新的Entry空数组，长度是原数组的2部。

2. ReHash：变量原数组，然后把所有Entry重新Hash到新数组。

在并发情况下会造成循环链表，死循环。

https://blog.csdn.net/bjwfm2011/article/details/81076736



# `ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？` 

红黑树查找更快，保证线程安全采用了       synchronized 和CAS。

# `AQS` 

全名：AbstractQueuedSynchronizer，是构建锁和同步器提供的一种基础框架。底层使用先进先出的FIFO等待队里来存放阻塞的线程。核心方法主要独占资源(acquire)和共享资源(share acquire)。核心属性还有一个int类型的stat变量，你可以自定此变量的意义。比如独占锁的重入功能，共享锁的获取资源数量。

当然可能单独 FIFO队列无法满足一些情况，比如闭锁。

# `如何检测死锁？怎么预防死锁？` 

检测死锁可以使用 jstack 查看 java 栈，如果出现死锁，那么内容最下方会出现 dealock标识。

预防死锁：主要是避免锁嵌套使用，同时锁使用完记得释放锁。



# `Java 内存模型？ `

java内存模型就是JMM，jmm定义了线程内存和主内存之间的抽象管理。同时JMM屏蔽了各个系统内存差异化。

# `如何保证多线程下 i++ 结果正确？ `

同步



# `线程池的种类，区别和使用场景？` 

Executor

为什么使用线程池，使用线程池适用于频繁创建、销毁线程的场景，创建线程其实很消耗资源，这时候可以服用线程资源，所以有了线程池。

固定线程池：线程池中的线程数量不变。任务队里采用LinkedBlockingQueue，无界队列。

只有一个线程的线程池。多余任务会保存到任务队列中。

延时线程池。



# `分析线程池的实现原理和线程的调度过程？` 

Executors

底层是使用ThreadPoolExecutor类，他有5个参数，核心线程数量、最大线程数量、线程池超过核心线程数后的多余线程存活时间、任务队列、线程工厂(用于创建线程)、拒绝策略。

调度策略是，先判断当前执行任务数量是否大于核心线程数，如果小于直接执行，大于则提交到任务队里，如果任务队列满了，则创建线程到最大线程数，如果大于最大线程数，则执行拒绝策略。



# `线程池如何调优，最大数目如何确认？` 

线程池最好自己手动ThreadPoolExecutor，这样可空性更强。

很多时候最简单 粗暴的是: 

如果是IO密集型应用，则线程池大小设置为2N+1； 

如果是CPU密集型应用，则线程池大小设置为N+1；

 

# `线程池的状态有几种？`

 在ThreadPoolExecutor中，其类变量ctl的高三位代表线程池状态：

- RUNNING：运行状态，正常工作

- SHUTDOWN：关闭状态，不接受新任务，但会处理在阻塞队列中排队的队伍

- STOP：停止状态，不接受新任务，也不处理排队的任务，同时会中断执行中的任务

- TIDYING：整理状态，所有任务终止，没有工作线程，即将运行terminated方法来终结线程池

- TERMINATED：终结状态，terminated方法结束后线程池终结



状态的转换通过以下方式：

![avatar](https://s2.ax1x.com/2019/10/11/uqeV0K.jpg)


# `ThreadLocal原理，用的时候需要注意什么？` 

在并发编程时会产生线程安全问题，一般都是多个线程同时操作统一资源，ThreadLocal的思想是，每个线程持有一份自己的引用，那么久不会产生问题。

THread类中有一个ThreadLocalMap ，类似于Hashap，ThreadLocal的get方法就是获取当前线程里的ThreadLocalMap。使用时要注意：使用完后要注意remove ThreadLocalMap，否则会造成内存溢出。

 Random底层使用   private final AtomicLong seed;来做随机种子，在多线程并发是，竞争激烈，性能并不好。

# `CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?` 

CountDownLatch不能循环使用，同时CountDownLatch下一步行动的控制者是外部线程。而CyclicBarrier的下一步执行者是当前执行的线程。同时CyclicBarrier可以多次使用



# `LockSupport工具 `

一个线程阻塞工具，可以让线程阻塞。   底层是UNSAFE.park(false, 0L);

# `Condition接口及其实现原理 `

Condition类似于,wait()和notify,作用大致相同,不过wait和notify是个synchronized关键字合作使用的.而Condition是与重入锁相关联的.主要有：await方法，是当前线程等待，同时释放锁。singal()唤醒等待中的线程。

# `Fork/Join框架的理解 `

# `分段锁的原理,锁力度减小的思考` 

# `八种阻塞队列以及各个阻塞队列的特性`


# `有哪些线程安全的List`
CopyOnWriteArrayList ：读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array
# `线程java进程占用cpu 100%`
1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如123
2，按H，获取每个线程的内存情况
3，找到内存和cpu占用最高的线程pid，比如15248
4，执行 printf 0x%x 15248 得到 0x3b90 ,此为线程id的十六进制
5，执行 jstack 123|grep -A 10 3b90，得到线程堆栈信息中3b90这个线程所在行的后面10行
6，查看对应的堆栈信息找出可能存在问题的代码